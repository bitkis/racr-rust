## Board Generation
A board can be generated by chosing a unit together with other memory mapped peripheerals and peripherals attached to different interfaces.

## Unit Generation
Units can be generated by placing peripherals at specific addresses. This section defines how units are defined.

### Unit
A unit can be generated with the following syntax:
``` rust
///<description>
///<description>
...
///<description>
unit <identifier> {
    <peripheral[0]>,
    <peripheral[1]>,
    ...
    <peripheral[M]>,
}
```

| Element            | Type                     |  Condition     | Description  |
| ------------------ | ------------------------ | -------------- | ------------ |
| identifier         | String                   | required       |              |
| description        | String                   | optional       |              |
| peripheral         | [PeripheralInstance]     | 0+             |              |

### PeripheralInstance
A peripheral instance is defined by
``` rust
<name>: <peripheral> @ <address>
```

| Element            | Type                     |  Condition     | Description  |
| ------------------ | ------------------------ | -------------- | ------------ |
| name               | String                   | required       | The full name of the peripheral instance |
| peripheral         | String                   | required       | The identifier of the peripheral that is being istanciated |
| address            | uint                     | required       | The address where the peripheral is being instanciated  |

### Example
Example of how an incomplete RACR definition might look like for the NXP s32k116 is the following
``` rust
/// NXP - S32K116
///
/// Lightweight MCU from the S32K series.
unit S32K116
    gpio: Gpio @ 0x4000F000,
    ftfc: Ftfc @ 0x40020000,
    dmamux: Dmamux @ 0x40021000,
    flex_can0: FlexCanFd @ 0x40024000,
    flex_can1: FlexCan @ 0x40025000, // This flex can instance is of the kind without FD support
    // There are literaly a ton of omited peripherals.
}    
```


## Peripheral Generation
Peripherals will be generated as data types even if they are never used anywhere. This section defines how peripherals are specified in RACR.

### Peripheral
A peripheral type is created with the following syntax:
``` rust
///<description>
///<description>
...
///<description>
periphreal <identifier> {
    <register[0]>,
    <register[1]>,
    ...
    <register[M]>,
}
```

| Element            | Type                     |  Condition     | Description  |
| ------------------ | ------------------------ | -------------- | ------------ |
| ident              | String                   | required       |              |
| description        | String                   | optional       |              |
|||||
| register           | [RegisterInstance]       | 0+             |              |

### RegisterInstance
A register instance is defined as
``` rust
<name>: <peripheral> @ <offset>
```

| Element            | Type                     |  Condition     | Description  |
| ------------------ | ------------------------ | -------------- | ------------ |
| ident              | String                   | required       | The full name of the register instance |
| register           | String                   | required       | The identifier of the register that is being istanciated |
| offset             | uint                     | required       | Offset from the peripheral base address |

### Example
Example of how an incomplete RACR definition might look like for the NXP s32k116 FLEX_CAN peripheral is the following
``` rust
peripheral FLEX_CAN {
    mcr: MCR @ 0x000,
    ctrl1: CTRL1 @ 0x004,
    timer: TIMER @ 0x008,
    // omited a lot of registers
    rximr: [RXIMR; 32] @ 0x880 // yes, arrays are legal here
    // omited a lot more register
}
```

## Register Generation
This section defines how peripherals are specified in RACR.

### Register Definition
A reigster type is created by the following syntax:
``` rust
/// <description>
/// <description>
...
/// <description>
<access> register[<size>] <identifier> (= <reset_value>)? <": overlapping"?>  {
    <field[0]>,
    <field[1]>,
    ...
    <field[M]>,
}
```

| Element            | Type                     |  Condition     | Description  |
| ------------------ | ------------------------ | -------------- | ------------ |
| ident              | String                   | required       |              |
| description        | String                   | optional       |              |
|||||
| size               | uint                     | required       | Length in bits of the register representation, used for detecting out of bound fields | 
| overlapping        | bool                     | required       | If true, it allows other registers to overlap with this even if they both are read or both are write |
|||||
| access             | [Access]                 | required       | `ReadOnly`, `WriteOnly` or `ReadWrite`. A `WriteOnly`(`ReadOnly`) Register is allowed to overlap with `ReadOnly`(`WriteOnly`) registers even if overlapping is `false` |
| reset_value        | uint                     | optional       | If no reset value is specified it will be assumed that the reset value is undefined |
|||||
| fields             | [FieldInstance]          | 0+             |              |

### Field Instance
A field is instanciated with:
``` rust
///<description>
<access> <ident>[<bit_start>..<bit_end>]
```

| Element            | Type                     |  Condition     | Description  |
| ------------------ | ------------------------ | -------------- | ------------ |
| ident              | String                   | required       |              |
| description        | String                   | optional       |              |
|||||
| bit_start          | uint                     | required       | The starting bit of this field |
| bit_end            | uint                     | required       | Inclusive end of this field |
|||||
| access             | [Access]                 | required       | `ReadOnly`, `WriteOnly` or `ReadWrite`. A `WriteOnly`(`ReadOnly`) field is allowed to overlap with `ReadOnly`(`WriteOnly`) fields.

## Common
### Access
#### Definition
Access can be one of the following variants:
 - `ReadOnly`
 - `WriteOnly`
 - `ReadWrite`

#### Access rules
Some rules exists related to `Access`
 - If a `Register` is `WriteOnly` then all its fields must also be `WriteOnly`.
 - If a `Register` is `ReadOnly` then all its fields must also be `ReadOnly`.


[Access]: https://github.com/kjetilkjeka/racr-format/master/specification#access
